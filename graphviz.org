#+TITLE: Docker Containers
*DOCKER* is a virtualized container software that takes your applications, their
 depedencies and isolates them in a "container" from other applications or libs.
 Containers are also useful in development environments where there's a lot of
 testing.
* Data

#+name: lista
#+begin_src elisp
  (org-element-map (org-element-parse-buffer 'headline )
      'headline
    (lambda(hl)
      (let ((parent (org-element-property :parent hl )))
        (and (eq (org-element-type parent) 'headline)
             (list (org-element-property :title parent) (org-element-property :title hl))))))

#+end_src

#+RESULTS: lista

#+name: make-dot
#+BEGIN_SRC emacs-lisp :var table=lista :results output :exports none
  (mapcar #'(lambda (x)
                (princ (format "\"%s\" -> \"%s\";\n" (first x) (second x))))
          table)
#+END_SRC

#+BEGIN_SRC dot :file dependencias.pdf :cmdline -Tpdf :var input=make-dot :exports results
digraph Q {
   rankdir=TB;
   splines=true;
   node [shape=box];
   $input
  }
#+END_SRC

#+BEGIN_SRC plantuml :file steps.jpg

c4140 -- gpuSlot5
c4140 -- gpuSlot6

gpuSlot4 <-left-> gpuSlot7 #blue :swap
gpuSlot5 <-left-> gpuSlot6 #blue :swap
gpuSlot6 -down- gpuSlot7
gpuSlot5 -down- gpuSlot4


c4130 -- gpuCard2
c4130 -- gpuCard3

gpuCard1 -right- gpuCard2
gpuCard3 -right- gpuCard4
gpuCard2 <-> gpuCard3 #blue :swap
gpuCard1 <-right-> gpuCard4 #blue :swap

gpuIssues -up- gpuChart

class gpuChart #white {
~symptom
+action
#data
}

class gpuIssues #white {
~gpuReplays
+swap gpuCard
+reseat riserCable
==
~gpuMissing
+swap gpuCard
+reseat riserCable
+reseat powerCable
==
~gpuMemoryErrors
+swap gpuCard
}

class c4130 {
gpuCard{}
riserCable{}
powerCable{}
}

class gpuCard1 {}
class gpuCard2 {}
class gpuCard3 {}
class gpuCard4 {}

class c4140 {
riserCable{}
powerCable{}
gpuCard{}
nvLinkboard{}
motherBoard{}
CPU{}
}

class gpuSlot4 {
-BUS AF:00
-GPU 0
-CPU0
}

class gpuSlot5 {
-BUS 86:00
-GPU 1
-CPU0
}

class gpuSlot6 {
-BUS 18:00
-GPU 2
-CPU1
}

class gpuSlot7 {
-BUS 43:00
-GPU3
-CPU1
}

#+END_SRC

#+RESULTS:
[[file:steps.jpg]]

* Installation
 First you'll need to install Docker on your box, for ubuntu this can be easily
 done by running:
 : sudo apt install docker.io -y

 Otherwise, you can follow the steps listed below
 #+BEGIN_SRC shell
sudo apt-get remove docker \
    docker-engine \
    docker.io \
    containerd \
    runc \
    && sudo apt-get update \
    && sudo apt-get install apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common -y
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - && apt-key fingerprint 0EBFCD88
sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
sudo apt-get update \
    && apt-get install docker-ce \
    docker-ce-cli \
    containerd.io -y
 #+END_SRC
* Docker Containers
The *container* is where the magic happens. It's where your application runs
with all of the libs/apps/modules that are required to make that application
run. *Images* are basically pre-cooked applications that are packaged and ready
to be deployed in a container. Some of these images come with *ENV* variables to
allow customizing the container at launch.

So how do you run a container? The easiest way is something like the following
: sudo docker run -it mysql:latest
* Running MYSQL with shared storage
For more info check out [[file:mysql.org]]
#+BEGIN_SRC shell
docker run -d --name=new-mysql -p 6604:3306 -v /storage/docker/mysql-datadir:/var/lib/mysql mysql
#+END_SRC
